import got from 'got'
import * as constants from './constants.js'

export async function poll({
                             apiUrl,
                             collectionToken,
                             customerId,
                             eventId,
                             onStatusUpdate,
                             pollTimeout = 10,
                             pollInterval = 5000,
                           }) {
  const pollingUrl = `https://${apiUrl}${constants.PollingEndpoint}/${eventId}`
  const headers = {
    [constants.LightlyticsTokenKey]: collectionToken,
  }

  let pollCount = 0
  let lastStatus = ''
  while (pollCount < (pollTimeout * 60 * 1000) / pollInterval) {
    await new Promise(resolve => setTimeout(resolve, pollInterval))
    pollCount++

    const response = await got.get(pollingUrl, {
      responseType: 'json',
      headers,
    })

    const status = statusToGithubChecks(response.body?.status || 'pending')

    if ((pollCount >= (pollTimeout * 60 * 1000) / pollInterval) && !status.conclusion) {
      console.log(`Simulation result timed out with status: ${status.status}`)
      status.conclusion = 'neutral' // 'timed_out' will not allow merging
      status.label = 'Timed-out'
      status.emoji = ':hourglass:'
      status.status = 'completed'
    }

    if (lastStatus !== status.status) {
      lastStatus = status.status
      const sortedViolations = (response.body?.violations || [])
        .sort((a, b) =>
          categoryImportance(b.category) - categoryImportance(a.category) || b.severity - a.severity,
        )
      onStatusUpdate(status, sortedViolations)
    }

    if (status.conclusion) {
      break
    }
  }
}

function categoryImportance(category = '') {
  switch (category.toLowerCase()) {
    case 'security':
      return 4
    case 'availability':
      return 3
    case 'cost':
      return 2
    case 'other':
      return 1
  }
  return 0
}

function severityToString(severity = 1) {
  switch (severity) {
    case 4:
      return 'Critical'
    case 3:
      return 'High'
    case 2:
      return 'Medium'
    case 1:
      return 'Low'
  }
  return 'Info'
}

function statusToGithubChecks(status) {
  switch (status) {
    case 'pending':
      return {
        label: 'Pending',
        status: 'queued',
      }
    case 'processing':
      return {
        label: 'Processing',
        status: 'in_progress',
      }
    case 'error':
      return {
        label: 'Errored',
        emoji: ':lady_beetle:',
        status: 'completed', // queued, in_progress, completed
        conclusion: 'neutral', // action_required, cancelled, failure, neutral, success, skipped, timed_out
      }
    case 'failed':
      return {
        label: 'Failed',
        emoji: ':x:',
        status: 'completed',
        conclusion: 'failure',
      }
    default:
    case 'done':
      return {
        label: 'Passed',
        emoji: ':white_check_mark:',
        status: 'completed',
        conclusion: 'success',
      }
  }
}

function categoryToMarkdown(category) {
  switch (category) {
    case 'Security':
      return ':lock: Security'
    case 'Cost':
      return ':moneybag: Cost'
    case 'Availability':
      return ':arrow_lower_right: Availability'
    case 'Other':
      return ':open_file_folder: Other'
  }
  return category
}

const identTab = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'

export function getMarkdownComment(status, violations = [], details_url) {
  let violationSummary = ''

  const formatViolation = violation =>
    `(*${severityToString(violation.severity)}*) "${violation.name}" [${violation.count} occurrences]${violation.fail_simulation ? ' - :x: Failed simulation' : ''}\n`

  let forceFailCount = 0
  let lastCategory = violations[0]?.category
  if (lastCategory) {
    violationSummary += `**${categoryToMarkdown(lastCategory)}**\n`
  }

  for (const violation of violations) {
    if (lastCategory !== violation.category) {
      lastCategory = violation.category

      violationSummary += `\n\n`
      violationSummary += `**${categoryToMarkdown(violation.category)}**\n`
    }

    if (violation.fail_simulation) forceFailCount++
    violationSummary += formatViolation(violation)
  }

  return `An execution simulation has been generated by **Lightlytics** [View simulation details](${details_url})\n\n` +
    `*Simulation Status:* ${status.emoji}${status.label}\n` +
    `${identTab}*Total violations count: ${violations.length}*\n${identTab}*Forced failed violations count: ${forceFailCount}*` +
    '\n\n' + (violationSummary ? `<details><summary>Violations Summary:</summary>\n\n${violationSummary}</details>` : 'No violations were found') +
    '\n\n' + '> _This comment was added automatically by a git workflow to help DevOps teams predict what will be the impact of the proposed change after completing this PR_'
}
