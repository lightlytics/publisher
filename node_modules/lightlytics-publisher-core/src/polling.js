import got from "got"
import * as constants from "./constants.js"

export async function poll({
                             apiUrl,
                             collectionToken,
                             customerId,
                             eventId,
                             onStatusUpdate,
                             pollTimeout = 10,
                             pollInterval = 5000
                           }) {
  const pollingUrl = `https://${apiUrl}${constants.PollingEndpoint}/${eventId}`
  const headers = {
    [constants.LightlyticsTokenKey]: collectionToken,
  }

  let pollCount = 0
  let lastStatus = ""
  while (pollCount < (pollTimeout * 60 * 1000) / pollInterval) {
    await new Promise(resolve => setTimeout(resolve, pollInterval))
    pollCount++

    const response = await got.get(pollingUrl, {
      responseType: "json",
      headers,
    });

    const details_url = `https://${apiUrl}/w/${customerId}/simulations/${eventId}`
    const status = statusToGithubChecks(response.body?.status || 'pending')

    if ((pollCount >= (pollTimeout * 60 * 1000) / pollInterval) && !status.conclusion) {
      console.log(`Simulation result timed out with status: ${status.status}`)
      status.conclusion = 'neutral' // 'timed_out' will not allow merging
      status.label = 'Timed-out'
      status.emoji = ':hourglass:'
      status.status = 'completed'
    }

    if (lastStatus !== status.status) {
      lastStatus = status.status
      onStatusUpdate(status, response.body?.violations)
    }

    if (status.conclusion) {
      break
    }
  }
}

function statusToGithubChecks(status) {
  switch (status) {
    case 'pending':
      return {
        label: 'Pending',
        status: 'queued'
      }
    case 'processing':
      return {
        label: 'Processing',
        status: 'in_progress'
      }
    case 'error':
      return {
        label: 'Errored',
        emoji: ':lady_beetle:',
        status: 'completed', // queued, in_progress, completed
        conclusion: 'neutral' // action_required, cancelled, failure, neutral, success, skipped, timed_out
      }
    case 'failed':
      return {
        label: 'Failed',
        emoji: ':x:',
        status: 'completed',
        conclusion: 'failure'
      }
    default:
    case 'done':
      return {
        label: 'Passed',
        emoji: ':white_check_mark:',
        status: 'completed',
        conclusion: 'success'
      }
  }
}

function categoryToMarkdown(category) {
  switch (category) {
    case 'Security':
      return ':lock: Security'
    case 'Cost':
      return ':moneybag: Cost'
    case 'Availability':
      return ':arrow_lower_right: Availability'
    case 'Other':
      return ':open_file_folder: Other'
  }
  return category
}

const identTab = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'

export function getMarkdownComment(status, violations = [], details_url) {
  let violationSummary = ""

  const formatViolation = violation =>
    `(*${violation.severity}*) "${violation.name}" [${violation.count} occurrences]${violation.fail_simulation ? ' - :x: Failed simulation' : ''}`

  let forceFailCount = 0
  // Group by category
  const groupedViolations = violations.reduce((acc, violation) => {
    if (violation.fail_simulation) forceFailCount++
    (acc[violation.category] = acc[violation.category] || []).push(formatViolation(violation))
    return acc
  }, {})

  for (const category in groupedViolations) {
    violationSummary += `**${categoryToMarkdown(category)}**\n`
    violationSummary += groupedViolations[category].join('\n')
    violationSummary += `\n\n`
  }

  return `An execution simulation has been generated by **Lightlytics** [View simulation details](${details_url})\n\n` +
    `*Simulation Status:* ${status.emoji}${status.label}\n` +
    `${identTab}*Total violations count: ${violations.length}*\n${identTab}*Forced failed violations count: ${forceFailCount}*` +
    '\n\n' + (violationSummary ? `<details><summary>Violations Summary:</summary>\n\n${violationSummary}</details>` : 'No violations were found') +
    '\n\n' + '> _This comment was added automatically by a git workflow to help DevOps teams predict what will be the impact of the proposed change after completing this PR_'
}
